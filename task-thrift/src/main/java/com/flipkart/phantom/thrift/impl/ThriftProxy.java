/*
 * Copyright 2012-2015, the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.flipkart.phantom.thrift.impl;

import com.flipkart.phantom.task.spi.AbstractHandler;
import com.flipkart.phantom.task.spi.TaskContext;
import com.flipkart.phantom.task.utils.StringUtils;
import org.apache.thrift.ProcessFunction;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * <code>ThriftProxy</code> holds the details of a ThriftProxy and loads the necessary Thrift Classes.
 * 
 * @author Regunath B
 * @version 1.0, 28 March, 2013
 */
public abstract class ThriftProxy extends AbstractHandler {

	/** The default Thrift interface class name for Thrift services */
	private static final String DEFAULT_SERVICE_INTERFACE_NAME="Iface";
	
	/** The default Thrift TProcessor class name */
	private static final String DEFAULT_PROCESSOR_CLASS_NAME="Processor";
	
	/** The default executor timeout in millis*/
	private static final int DEFAULT_EXECUTOR_TIMEOUT = 1000;
	
	/** Logger for this class*/
	private static final Logger LOGGER = LoggerFactory.getLogger(HystrixThriftProxy.class);
	
	/** The executor timeout millis*/
	private int executorTimeout = DEFAULT_EXECUTOR_TIMEOUT;
	
	/** The target Thrift server connect details*/
	private String thriftServer;
	private int thriftPort;
	private int thriftTimeoutMillis = -1;
	
	/** The fully qualified class name of the Thrift service generated by the Thrift compiler from the IDL file*/
	private String thriftServiceClass;

	/** Map of the method names and the respective Thrift ProcessFunction instances*/
	@SuppressWarnings("rawtypes")
	private Map<String, ProcessFunction> processMap = new HashMap<String, ProcessFunction>();
	

	/**
	 * Initialize this ThriftProxy
	 */
	public void init(TaskContext context) throws Exception {
		if (this.thriftServiceClass == null) {
			throw new AssertionError("The 'thriftServiceClass' may not be null");
		}
		if (this.processMap == null || this.processMap.isEmpty()) {
			throw new AssertionError("ProcessFunctions not populated. Maybe The 'thriftServiceClass' is not a valid class?");
		}
		if (this.thriftTimeoutMillis == -1) {
			throw new Exception("'thriftTimeoutMillis' must be set to a non-negative value!");
		}
	}

	/**
	 * Get the name of this ThriftProxy.
	 * @return the name of this ThriftProxy
	 */
	public String getName() {
		return this.thriftServiceClass;
	}

    /**
     * Abstract method implementation
     * @see com.flipkart.phantom.task.spi.AbstractHandler#getDetails()
     */
    public String getDetails() {
        String details = "Service Class: " + this.getThriftServiceClass() + "\n";
        details += "Endpoint: " + this.getThriftServer() + ":" + this.getThriftPort() + "\n";
        details += "Timeout: " + this.getThriftTimeoutMillis() + "ms\n";
        details += "Executor Timeout: " + this.getExecutorTimeout() + "ms\n";
        details += "Methods: " + StringUtils.join(processMap.keySet().toArray(new String[]{}),", ") + "\n";
        return details;
    }

    /**
     * Abstract method implementation
     * @see com.flipkart.phantom.task.spi.AbstractHandler#getType()
     */
    public String getType() {
        return "ThriftProxy";
    }

	/**
	 * Shutdown hooks provided by the ThriftProxy
	 */
	public void shutdown(TaskContext context) throws Exception {

	}
	
	/** Getter/Setter methods */
	public String getThriftServer() {
		return thriftServer;
	}
	public void setThriftServer(String thriftServer) {
		this.thriftServer = thriftServer;
	}
	public int getThriftPort() {
		return thriftPort;
	}
	public void setThriftPort(int thriftPort) {
		this.thriftPort = thriftPort;
	}
	public int getThriftTimeoutMillis() {
		return thriftTimeoutMillis;
	}
	public void setThriftTimeoutMillis(int thriftTimeoutMillis) {
		this.thriftTimeoutMillis = thriftTimeoutMillis;
	}	
	@SuppressWarnings("rawtypes")
	public void setThriftServiceClass(String thriftServiceClass) {
		this.thriftServiceClass = thriftServiceClass;
		// Inspect and add ProcessFunction instances for all public methods on the declared service interface
		String serviceInterfaceClass = this.thriftServiceClass + "$" + DEFAULT_SERVICE_INTERFACE_NAME;
		try {
			Class serviceClass = Class.forName(serviceInterfaceClass);
			Method[] methods = serviceClass.getDeclaredMethods();
			for (Method method : methods) {
				String processFunctionClass = this.thriftServiceClass + "$" + DEFAULT_PROCESSOR_CLASS_NAME + "$" + method.getName();
				this.processMap.put(method.getName(), (ProcessFunction)Class.forName(processFunctionClass).newInstance());
			}
		} catch (Exception e) {
			LOGGER.error("Unable to inspect specified Thrift service class. Error is : " + e.getMessage(), e);
			// empty the processMap. This will fail the init of this handler in #afterPropertiesSet()
			this.processMap.clear();
		}		
	}
	public String getThriftServiceClass() {
		return thriftServiceClass;
	}
	public Map<String, ProcessFunction> getProcessMap() {
		return processMap;
	}
	public int getExecutorTimeout() {
		return this.executorTimeout;
	}
	public void setExecutorTimeout(int executorTimeout) {
		this.executorTimeout = executorTimeout;
	}	
	/** End Getter/Setter methods */

}
